<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>whatsamacro.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <link rel='stylesheet' href='https://unpkg.com/normalize.css/'>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/pietroppeter/nimib/assets/atom-one-light.css'>
  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href=".">üè°</a></span>
  <span><code>whatsamacro.nim</code></span>
  <span><a href="https://github.com/beef331/beef331.github"><svg aria-hidden="true" width="1.2em" height="1.2em" style="vertical-align: middle;" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59c.4.07.55-.17.55-.38c0-.19-.01-.82-.01-1.49c-2.01.37-2.53-.49-2.69-.94c-.09-.23-.48-.94-.82-1.13c-.28-.15-.68-.52-.01-.53c.63-.01 1.08.58 1.23.82c.72 1.21 1.87.87 2.33.66c.07-.52.28-.87.51-1.07c-1.78-.2-3.64-.89-3.64-3.95c0-.87.31-1.59.82-2.15c-.08-.2-.36-1.02.08-2.12c0 0 .67-.21 2.2.82c.64-.18 1.32-.27 2-.27c.68 0 1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82c.44 1.1.16 1.92.08 2.12c.51.56.82 1.27.82 2.15c0 3.07-1.87 3.75-3.65 3.95c.29.25.54.73.54 1.48c0 1.07-.01 1.93-.01 2.2c0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z" fill="#000"></path></svg></a></span>
</div>
<hr>
</header><main>
<p>To begin let's look at the most basic example of Nim metaprogramming.
Templates! These are very simple code subsitutions.
When you call a template it pastes it's body with the code replaced at the callsite&quot;
Now you might be asking &quot;Now what does that look like?!&quot;</p>
<pre><code class="nim hljs"><span class="hljs-keyword">template</span> thisIsATemplate() =
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello from template&quot;</span>

thisIsATemplate()</code></pre>
<pre><samp>Hello from template
</samp></pre>
<p>In this case when we call <code>thisIsATemplate</code> it simply just pastes <code>echo &quot;Hello from template&quot;</code>.
Now to look at a more elaborate example that uses passed in symbols.</p>
<pre><code class="language-nim">template makeVar(name, value: untyped) =
  var name = value
makeVar(hello, &quot;world&quot;)
echo hello
</code></pre>
<p>&quot;What does this template do, what's <code>untyped</code>?!&quot;</p>
<p>Nim has two built in types for metaprogramming <code>typed</code> and <code>untyped</code>.
The latter is used for passing code that you do not want to be semantically checked, which means you do not want it checked in the compiler just the straight code from the value.
Now what the template does, you can compile your program with <code>--expandMacro:makeVar</code> or use <code>macros.expandMacros</code> and it'll show you exactly what it did.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">import</span>
  std / macros

<span class="hljs-keyword">template</span> makeVar(name, value: <span class="hljs-built_in">untyped</span>) =
  <span class="hljs-keyword">var</span> name = value

expandMacros:
  makeVar(hello, <span class="hljs-string">&quot;world&quot;</span>)</code></pre>
<p>This outputs the following at compile time:</p>
<pre><code class="language-nim">var hello = &quot;world&quot;
</code></pre>
<p>As you can see all it did was paste the <code>name</code> and <code>value</code> parameter into the statement.
With a minor modification we've succesfully made the Go walrus operator.</p>
<pre><code>template `:=`(name, value: untyped) = var name = value
</code></pre>

</main>
<footer>
<hr>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nim hljs"><span class="hljs-keyword">import</span> nimib
nbInit()

<span class="hljs-string">nbText&quot;&quot;&quot;
To begin let's look at the most basic example of Nim metaprogramming.
Templates! These are very simple code subsitutions.
When you call a template it pastes it's body with the code replaced at the callsite&quot;
Now you might be asking &quot;Now what does that look like?!&quot;
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">template</span> thisIsATemplate() = <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello from template&quot;</span>
  thisIsATemplate()

<span class="hljs-string">nbText&quot;&quot;&quot;
In this case when we call `thisIsATemplate` it simply just pastes `echo &quot;Hello from template&quot;`.
Now to look at a more elaborate example that uses passed in symbols.
```nim
template makeVar(name, value: untyped) =
  var name = value
makeVar(hello, &quot;world&quot;)
echo hello
```
&quot;&quot;&quot;</span>

<span class="hljs-string">nbText&quot;&quot;&quot;
&quot;What does this template do, what's `untyped`?!&quot;

Nim has two built in types for metaprogramming `typed` and `untyped`.
The latter is used for passing code that you do not want to be semantically checked, which means you do not want it checked in the compiler just the straight code from the value.
Now what the template does, you can compile your program with `--expandMacro:makeVar` or use `macros.expandMacros` and it'll show you exactly what it did.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">import</span> std/macros
  <span class="hljs-keyword">template</span> makeVar(name, value: <span class="hljs-built_in">untyped</span>) =
    <span class="hljs-keyword">var</span> name = value
  expandMacros:
    makeVar(hello, <span class="hljs-string">&quot;world&quot;</span>)

<span class="hljs-string">nbText&quot;&quot;&quot;
This outputs the following at compile time:
```nim
var hello = &quot;world&quot;
```
As you can see all it did was paste the `name` and `value` parameter into the statement.
With a minor modification we've succesfully made the Go walrus operator.
```
template `:=`(name, value: untyped) = var name = value
```
&quot;&quot;&quot;</span>



















nbSave()
</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>